#include <iostream>
using namespace std;

class SparseRow {
    protected:
        int row; //Row#
        int col; //Column#
        int value; //We will assume that all our values will be integers
    public:
        SparseRow (); //default constructor; row=-1;col=-1;value=0
        void display(); // print Row#, Column#, value
        friend ostream &operator<<(ostream &s, SparseRow sr);
        //other methods that are necessary such as get and set
        
        // Getter methods
        int getRow() const;
        int getCol() const;
        int getValue() const;

        // Setter methods
        void setRow(int r);
        void setCol(int c);
        void setValue(int v);
};

SparseRow::SparseRow()
{
    row = -1;
    col = -1;
    value = 0;
}

int SparseRow::getRow() const {
    return row;
}

int SparseRow::getCol() const {
    return col;
}

int SparseRow::getValue() const {
    return value;
}

// Setter method definitions
void SparseRow::setRow(int r) {
    row = r;
}

void SparseRow::setCol(int c) {
    col = c;
}

void SparseRow::setValue(int v) {
    value = v;
}

void SparseRow::display()
{
    cout << row << ", " << col << ", " << value << endl;
}

ostream &operator<<(ostream &s, SparseRow sr)
{
    sr.display();
    return s;
}

class SparseMatrix {
    protected:
        int noRows; //Number of rows of the original matrix
        int noCols; //Number of columns of the original matrix
        int commonValue; //read from input
        int noNonSparseValues;
        SparseRow* myMatrix; //Array
    public:
        SparseMatrix ();
        SparseMatrix (int n, int m, int cv, int numNSV); //Constructor
        SparseMatrix (SparseMatrix& M); //Copy Constructor
        SparseMatrix* Transpose (); //Matrix Transpose
        SparseMatrix* Multiply (SparseMatrix& M);
        SparseMatrix* Add (SparseMatrix& M);
        friend ostream& operator<< (ostream& s, SparseMatrix& sm);
        void displayMatrix (); //Display the matrix in its original format
        //other methods that are necessary such as get and set
};

SparseMatrix::SparseMatrix()
{
    noRows = 0;
    noCols = 0;
    commonValue = 0;
    noNonSparseValues = 0;
    myMatrix = NULL;
}

SparseMatrix::SparseMatrix(int n, int m, int cv, int numNSV)
{
    noRows = n;
    noCols = m;
    commonValue = cv;
    noNonSparseValues = numNSV;
    myMatrix = new SparseRow[noNonSparseValues];
    for(int i = 0; i < noNonSparseValues; i++){
        int val;
        for(int j = 0; j < noRows; j++){
            for(int k = 0; 0 < noCols; k++){
                cin >> val;
                if(val != commonValue){
                    myMatrix[i].setRow(j);
                    myMatrix[i].setCol(k);
                    myMatrix[i].setValue(val);
                }
            }
        }
    }
}

SparseMatrix::SparseMatrix(SparseMatrix& M)
{
    noRows = M.noRows;
    noCols = M.noCols;
    commonValue = M.commonValue;
    noNonSparseValues = M.noNonSparseValues;
    myMatrix = new SparseRow[noNonSparseValues];
    for (int i = 0; i < noNonSparseValues; i++)
    {
        myMatrix[i] = M.myMatrix[i];
    }
}
//Generated by CoPilot
SparseMatrix* SparseMatrix::Transpose()
{
    SparseMatrix* temp = new SparseMatrix(*this);
    for (int i = 0; i < noCols; i++)
    {
        for (int j = 0; j < noRows; j++)
        {
            if (myMatrix[j].getCol() == i)
            {
                temp->myMatrix[i].setRow(myMatrix[j].getCol());
                temp->myMatrix[i].setCol(myMatrix[j].getRow());
                temp->myMatrix[i].setValue(myMatrix[j].getValue());    
            }
        }
    }
    return temp;
}

//generated by CoPilot

SparseMatrix* SparseMatrix::Multiply(SparseMatrix& M)
{
    SparseMatrix* temp = new SparseMatrix(noRows, M.noCols, commonValue, 0);
    for (int i = 0; i < noRows; i++)
    {
        for (int j = 0; j < M.noCols; j++)
        {
            int sum = 0;
            for (int k = 0; k < noCols; k++)
            {
                sum += myMatrix[i * noCols + k].getValue() * M.myMatrix[k * M.noCols + j].getValue();
            }
            if (sum != commonValue)
            {
                temp->myMatrix[temp->noNonSparseValues].setRow(i);
                temp->myMatrix[temp->noNonSparseValues].setCol(j);
                temp->myMatrix[temp->noNonSparseValues].setValue(sum);
                temp->noNonSparseValues++;
            }
        }
    }
    return temp;
}

//Generated by CoPilot

SparseMatrix* SparseMatrix::Add(SparseMatrix& M)
{
    SparseMatrix* temp = new SparseMatrix(noRows, noCols, commonValue, noNonSparseValues);
    for (int i = 0; i < noRows; i++)
    {
        for (int j = 0; j < noCols; j++)
        {
            if (myMatrix[i * noCols + j].getValue() != commonValue || M.myMatrix[i * noCols + j].getValue() != commonValue)
            {
                temp->myMatrix[temp->noNonSparseValues].setRow(i);
                temp->myMatrix[temp->noNonSparseValues].setCol(j);
                temp->myMatrix[temp->noNonSparseValues].setValue(myMatrix[i * noCols + j].getValue() + M.myMatrix[i * noCols + j].getValue());
                temp->noNonSparseValues++;
            }
        }
    }
    return temp;
}

//generated by CoPilot

void SparseMatrix::displayMatrix()
{
    int val;

    for(int i = 0; i < noRows; i++){
        for(int j = 0; j < noCols; j++){
            cin >> val;
            if(val != commonValue){
                cout << i << ", " << j << ", " << val << endl;
            }
        }
    }
}

//Generated by Copilot

ostream& operator<<(ostream& s, SparseMatrix& sm)
{
    for (int i = 0; i < sm.noRows; i++)
    {
        for (int j = 0; j < sm.noCols; j++)
        {
            s << sm.myMatrix[i * sm.noCols + j];
        }
    }
    return s;
}

int main () {

    int row, col, cv, numNSV, val;

    SparseMatrix* temp;
    //Write the Statements to read in the first matrix
    cin >> row >> col >> cv >> numNSV;

    SparseMatrix* firstOne = new SparseMatrix(row, col, cv, numNSV);

    cout << "First one in sparse matrix format" << endl;
    (*firstOne).displayMatrix();

    cout << "After transpose" << endl;
    (*(*firstOne).Transpose()).displayMatrix();

    //Write the Statements to read in the second matrix
    cin >> row >> col >> cv >> numNSV;

    SparseMatrix* secondOne = new SparseMatrix(row, col, cv, numNSV);

    cout << "Second one in matrix format" << endl;
    (*secondOne).displayMatrix();


    
    // cout << (*(*firstOne).Transpose());

    // cout << "Matrix Addition Result" << endl;
    // temp = ((*firstOne).Add(*secondOne));
    // cout << temp;
    // (*temp).displayMatrix();
    
    // cout << "Matrix Multiplication Result" << endl;
    // temp = ((*firstOne).Multiply(*secondOne));
    // cout << temp;
    // (*temp).displayMatrix();

    return 0;
}


